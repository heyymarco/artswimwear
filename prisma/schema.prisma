// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}
datasource db {
    provider = "mongodb"
    url      = env("DATABASE_URL")
}



enum ProductVisibility {
    PUBLISHED
    HIDDEN
    DRAFT
}
model Product {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    createdAt               DateTime                @default(now())
    updatedAt               DateTime                @updatedAt
    
    // data:
    visibility              ProductVisibility
    
    name                    String
    
    price                   Float                   // min: 0
    shippingWeight          Float?                  // min: 0
    
    stock                   Int?                    // min: 0
    
    path                    String                  @unique
    
    excerpt                 String?
    description             Json?
    
    images                  String[]
    
    // relations:
    orders                  OrdersOnProducts[]      // some Product(s) may have some related Order(s)       // many to many
    draftOrders             DraftOrdersOnProducts[] // some Product(s) may have some related DraftOrder(s)  // many to many
}



type ShippingRate {
    // data:
    startingWeight          Float                   // min: 0, max: 1000     
    rate                    Float                   // min: 0, max: 999999999
}
type CoverageCity {
    // data:
    city                    String                  // minLength: 3, maxLength: 50
    
    estimate                String?                 // minLength: 2, maxLength: 50
    shippingRates           ShippingRate[]
}
type CoverageZone {
    // data:
    zone                    String                  // minLength: 3, maxLength: 50
    
    estimate                String?                 // minLength: 2, maxLength: 50
    shippingRates           ShippingRate[]
    
    useSpecificArea         Boolean?
    cities                  CoverageCity[]
}
type CoverageCountry {
    // data:
    country                 String                  // minLength: 2, maxLength: 3
    
    estimate                String?                 // minLength: 2, maxLength: 50
    shippingRates           ShippingRate[]
    
    useSpecificArea         Boolean?
    zones                   CoverageZone[]
}
model ShippingProvider {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    createdAt               DateTime                @default(now())
    updatedAt               DateTime                @updatedAt
    
    // data:
    enabled                 Boolean
    name                    String                  // minLength: 2, maxLength: 50
    
    weightStep              Float                   // min: 0, max: 1000
    
    estimate                String?                 // minLength: 2, maxLength: 50
    shippingRates           ShippingRate[]
    
    useSpecificArea         Boolean?
    countries               CoverageCountry[]
    
    // relations:
    orders                  Order[]                 @relation("OrdersOnShipping")      // one ShippingProvider may have some related Order(s)       // one  to many
    draftOrders             DraftOrder[]            @relation("DraftOrdersOnShipping") // one ShippingProvider may have some related DraftOrder(s)  // one  to many
}



model Customer {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    createdAt               DateTime                @default(now())
    updatedAt               DateTime                @updatedAt
    
    // data:
    marketingOpt            Boolean?
    
    nickName                String                  // minLength: 2, maxLength: 30
    email                   String                  // minLength: 5, maxLength: 50
    
    // relations:
    orders                  Order[]                 @relation("OrdersOnCustomer") // one Customer may have some related Order(s)  // one  to many
}



model Country {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    
    // data:
    enabled                 Boolean
    name                    String
    
    code                    String                  // minLength: 2 , maxLength:  3
    dialCode                String
}



type Address {
    // data:
    firstName               String                  // minLength: 2 , maxLength: 30
    lastName                String                  // minLength: 1 , maxLength: 30
    
    phone                   String                  // minLength: 5 , maxLength: 15
    
    address                 String                  // minLength: 5 , maxLength: 90
    city                    String                  // minLength: 3 , maxLength: 50
    zone                    String                  // minLength: 3 , maxLength: 50
    zip                     String?                 // minLength: 2 , maxLength: 11
    country                 String                  // minLength: 2 , maxLength:  3
}
enum PaymentType {
    CARD
    PAYPAL
    CUSTOM
    MANUAL
    MANUAL_PAID
}
type Payment {
    // data:
    type                    PaymentType
    brand                   String?
    identifier              String?
    
    amount                  Float                   // min: 0
    fee                     Float                   // min: 0
    
    billingAddress          Address?
}
model PaymentConfirmation {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    reportedAt              DateTime?               // manually set
    reviewedAt              DateTime?               // manually set
    
    // data:
    token                   String                  @unique
    
    currency                String?                 // minLength: 3, maxLength: 3
    amount                  Float?                  // min: 0
    payerName               String?                 // minLength: 2, maxLength: 50
    paymentDate             DateTime?
    preferredTimezone       Int?
    
    originatingBank         String?                 // minLength: 2, maxLength: 50
    destinationBank         String?                 // minLength: 2, maxLength: 50
    
    rejectionReason         Json?
    
    // relations:
    orderId                 String                  @unique
    order                   Order                   @relation(fields: [orderId], references: [id], onDelete: Cascade) // delete the related PaymentConfirmation if the Order deleted
}
enum OrderStatus {
    NEW_ORDER
    PROCESSED
    ON_THE_WAY
    IN_TROUBLE
    COMPLETED
}
model Order {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    createdAt               DateTime                @default(now())
    updatedAt               DateTime                @updatedAt
    
    // data:
    orderId                 String                  @unique // a secondary id for public identifier
    orderStatus             OrderStatus             @default(NEW_ORDER)
    orderTrouble            Json?
    
    shippingAddress         Address?
    shippingCost            Float?                  // min: 0
    
    payment                 Payment
    
    // relations:
    items                   OrdersOnProducts[]      // some Product(s) may have some related Order(s)  // many to many
    
    customerId              String?
    customer                Customer?               @relation(fields: [customerId]         , references: [id], "OrdersOnCustomer", onDelete: SetNull) // preserve the related Order(s) if the Customer deleted
    
    shippingProviderId      String?
    shippingProvider        ShippingProvider?       @relation(fields: [shippingProviderId] , references: [id], "OrdersOnShipping", onDelete: SetNull) // preserve the related Order(s) if the ShippingProvider deleted
    
    paymentConfirmation     PaymentConfirmation?    // an Order may have one related PaymentConfirmation // one to one
    
    shippingTracking        ShippingTracking?       // an Order may have one related ShippingTracking // one to one
}
model OrdersOnProducts {
    // records:
    // @@id([productId, orderId])
    id                      String                  @id @default(cuid()) @map("_id")
    
    // data:
    price                   Float                   // min: 0
    shippingWeight          Float?                  // min: 0
    quantity                Int                     // min: 1
    
    // relations:
    orderId                 String
    order                   Order                   @relation(fields: [orderId]     , references: [id], onDelete: Cascade) // delete the related OrdersOnProducts(s) if the Order deleted
    
    productId               String?
    product                 Product?                @relation(fields: [productId]   , references: [id], onDelete: SetNull) // preserve the related Order(s) if the Product deleted
}
model DraftOrder {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    createdAt               DateTime                @default(now())
    expiresAt               DateTime
    
    // data:
    orderId                 String                  @unique // a secondary id for public identifier
    paypalOrderId           String?                 @unique // a secondary id for public identifier
    
    shippingAddress         Address?
    shippingCost            Float?                  // min: 0
    
    // relations:
    items                   DraftOrdersOnProducts[] // some Product(s) may have some related DraftOrder(s)  // many to many
    
    shippingProviderId      String?
    shippingProvider        ShippingProvider?       @relation(fields: [shippingProviderId] , references: [id], "DraftOrdersOnShipping", onDelete: SetNull) // preserve the related DraftOrder(s) if the ShippingProvider deleted
}
model DraftOrdersOnProducts {
    // records:
    // @@id([productId, draftOrderId])
    id                      String                  @id @default(cuid()) @map("_id")
    
    // data:
    price                   Float                   // min: 0
    shippingWeight          Float?                  // min: 0
    quantity                Int                     // min: 1
    
    // relations:
    draftOrderId            String
    draftOrder              DraftOrder              @relation(fields: [draftOrderId], references: [id], onDelete: Cascade) // delete the related DraftOrdersOnProducts(s) if the DraftOrder deleted
    
    productId               String?
    product                 Product?                @relation(fields: [productId]   , references: [id], onDelete: SetNull) // preserve the related DraftOrder(s) if the Product deleted
}
model ShippingTracking {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    
    // data:
    token                   String                  @unique
    
    shippingCarrier         String?                 // minLength: 1, maxLength: 50
    shippingNumber          String?                 // minLength: 1, maxLength: 50
    
    preferredTimezone       Int?
    
    // relations:
    orderId                 String                  @unique
    order                   Order                   @relation(fields: [orderId], references: [id], onDelete: Cascade)  // delete the related ShippingTracking if the Order deleted
    
    shippingTrackingLogs    ShippingTrackingLog[]   // a ShippingTracking may have some related ShippingTrackingLog(s) // one  to many
}
model ShippingTrackingLog {
    // records:
    id                      String                  @id @default(cuid()) @map("_id")
    reportedAt              DateTime?               // manually set
    
    // data:
    log                     String
    
    // relations:
    shippingTrackingId      String
    shippingTracking        ShippingTracking        @relation(fields: [shippingTrackingId], references: [id], onDelete: Cascade) // delete the related ShippingTrackingLog(s) if the ShippingTracking deleted
}
